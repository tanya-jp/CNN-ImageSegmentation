# -*- coding: utf-8 -*-
"""HW3.2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K-yZgjJMcE5QfoBCwLW-5N7xaqn4GYZX
"""

!git clone https://github.com/alexgkendall/SegNet-Tutorial.git
  
# delete unwanted folders 
import shutil
myfile="/content/SegNet-Tutorial/Example_Models"
shutil.rmtree(myfile)
myfile="/content/SegNet-Tutorial/Models"
shutil.rmtree(myfile)
myfile="/content/SegNet-Tutorial/Scripts"
shutil.rmtree(myfile)
myfile="/content/SegNet-Tutorial/docker"
shutil.rmtree(myfile)

import numpy as np
import cv2
import glob
import imageio


#TRAIN DATAS
impath = glob.glob("/content/SegNet-Tutorial/CamVid/train/*.png")
labelpath = glob.glob("/content/SegNet-Tutorial/CamVid/trainannot/*.png")
train_images = []
train_labels = []
train_new_img = []
for x in impath:
  img=cv2.imread((x) , cv2.IMREAD_UNCHANGED)
  size = img.shape
  reimg = cv2.resize(img, (572,572), interpolation = cv2.INTER_AREA)
  imgcopy = img
  
  im2arr = np.array(reimg)
  img2 = cv2.cvtColor(im2arr,cv2.COLOR_BGR2GRAY)
  imgcopy = cv2.cvtColor(imgcopy,cv2.COLOR_BGR2GRAY)
  img2 = cv2.normalize(img2.astype('float'), None, 0.0, 1.0, cv2.NORM_MINMAX)
  new_img = np.zeros((720,960,1))
  
  
  
  for i in range(572):
    for j in range(572):
      new_img[i+73,j+194] = img2[i,j]  
  for i in range(720):
    for j in range(194):
      new_img[i,194-j] = new_img[i,194+j]
  for i in range(720):
    for j in range(766):
      new_img[i,194-j] = new_img[i,194+j]
  for i in range(74):
    for j in range(960):
      new_img[74-i,j] = new_img[74+i,j]
  for i in range(74):
    for j in range(960):
       new_img[572+73+i,j] = new_img[572+72-i,j]
        
        
  new_img = cv2.resize(new_img, (572,572), interpolation = cv2.INTER_AREA)
  train_new_img.append(new_img)
#TRAIN_LABEL        
for x in labelpath:
  label=cv2.imread((x) , cv2.IMREAD_UNCHANGED)
  relabel = cv2.resize(label, (572,572), interpolation = cv2.INTER_AREA)
  labelcopy = label
  label2 = np.array(relabel)
#   label2 = cv2.cvtColor(lb2arr,cv2.COLOR_BGR2RGB)
#   label2 = lb2arr
#   labelcopy = cv2.cvtColor(labelcopy,cv2.COLOR_BGR2RGB)
  new_label = np.zeros((720,960,1))
  
  
  for i in range(572):
    for j in range(572):
      new_label[i+73,j+194] = label2[i,j]  
  for i in range(720):
    for j in range(194):
      new_label[i,194-j] = new_label[i,194+j]
  for i in range(720):
    for j in range(766):
      new_label[i,194-j] = new_label[i,194+j]
  for i in range(74):
    for j in range(960):
      new_label[74-i,j] = new_label[74+i,j]
  for i in range(74):
    for j in range(960):
       new_label[572+73+i,j] = new_label[572+72-i,j]
        
  
  new_label = cv2.resize(new_label, (572,572), interpolation = cv2.INTER_AREA)
  train_labels.append(new_label)
  
import random
combined = list(zip(train_new_img,train_labels))
random.shuffle(combined)
train_new_img,train_labels = list(zip(*combined))


#TEST DATAS
impath = glob.glob("/content/SegNet-Tutorial/CamVid/test/*.png")
labelpath = glob.glob("/content/SegNet-Tutorial/CamVid/testannot/*.png")
test_images = []
test_labels = []
test_new_img = []
for x in impath:
  img=cv2.imread((x) , cv2.IMREAD_UNCHANGED)
  size = img.shape
  reimg = cv2.resize(img, (572,572), interpolation = cv2.INTER_AREA)
  imgcopy = img
  im2arr = np.array(reimg)
  img2 = cv2.cvtColor(im2arr,cv2.COLOR_BGR2GRAY)
  imgcopy = cv2.cvtColor(imgcopy,cv2.COLOR_BGR2GRAY)
  img2 = cv2.normalize(img2.astype('float'), None, 0.0, 1.0, cv2.NORM_MINMAX)
  new_img = np.zeros((720,960,1))
  
  
  for i in range(572):
    for j in range(572):
      new_img[i+73,j+194] = img2[i,j]  
  for i in range(720):
    for j in range(194):
      new_img[i,194-j] = new_img[i,194+j]
  for i in range(720):
    for j in range(766):
      new_img[i,194-j] = new_img[i,194+j]
  for i in range(74):
    for j in range(960):
      new_img[74-i,j] = new_img[74+i,j]
  for i in range(74):
    for j in range(960):
       new_img[572+73+i,j] = new_img[572+72-i,j]
        
  new_img = cv2.resize(new_img, (572,572), interpolation = cv2.INTER_AREA)
  test_new_img.append(new_img)
#TEST LABEL        
for x in labelpath:
  label=cv2.imread((x) , cv2.IMREAD_UNCHANGED)
  relabel = cv2.resize(label, (572,572), interpolation = cv2.INTER_AREA)
  labelcopy = label
  label2 = np.array(relabel)
#   label2 = cv2.cvtColor(lb2arr,cv2.COLOR_BGR2RGB)
#   labelcopy = cv2.cvtColor(labelcopy,cv2.COLOR_BGR2RGB)
  new_label = np.zeros((720,960,1))
  
  
  for i in range(572):
    for j in range(572):
      new_label[i+73,j+194] = label2[i,j]  
  for i in range(720):
    for j in range(194):
      new_label[i,194-j] = new_label[i,194+j]
  for i in range(720):
    for j in range(766):
      new_label[i,194-j] = new_label[i,194+j]
  for i in range(74):
    for j in range(960):
      new_label[74-i,j] = new_label[74+i,j]
  for i in range(74):
    for j in range(960):
       new_label[572+73+i,j] = new_label[572+72-i,j]
        
  
  new_label = cv2.resize(new_label, (572,572), interpolation = cv2.INTER_AREA)
  test_labels.append(new_label)
  
combined = list(zip(test_new_img,test_labels))
random.shuffle(combined)
test_new_img,test_labels = list(zip(*combined))


#VAL DATAS
impath = glob.glob("/content/SegNet-Tutorial/CamVid/val/*.png")
labelpath = glob.glob("/content/SegNet-Tutorial/CamVid/valannot/*.png")
val_images = []
val_labels = []
val_new_img = []
for x in impath:
  img=cv2.imread((x) , cv2.IMREAD_UNCHANGED)
  size = img.shape
  reimg = cv2.resize(img, (572,572), interpolation = cv2.INTER_AREA)
  imgcopy = img
  im2arr = np.array(reimg)
  img2 = cv2.cvtColor(im2arr,cv2.COLOR_BGR2GRAY)
  imgcopy = cv2.cvtColor(imgcopy,cv2.COLOR_BGR2GRAY)
  img2 = cv2.normalize(img2.astype('float'), None, 0.0, 1.0, cv2.NORM_MINMAX)
  new_img = np.zeros((720,960,1))
  
  
  for i in range(572):
    for j in range(572):
      new_img[i+73,j+194] = img2[i,j]  
  for i in range(720):
    for j in range(194):
      new_img[i,194-j] = new_img[i,194+j]
  for i in range(720):
    for j in range(766):
      new_img[i,194-j] = new_img[i,194+j]
  for i in range(74):
    for j in range(960):
      new_img[74-i,j] = new_img[74+i,j]
  for i in range(74):
    for j in range(960):
       new_img[572+73+i,j] = new_img[572+72-i,j]
        
  new_img = cv2.resize(new_img, (572,572), interpolation = cv2.INTER_AREA)
  val_new_img.append(new_img)
#VAL LABEL        
for x in labelpath:
  label=cv2.imread((x) , cv2.IMREAD_UNCHANGED)
  relabel = cv2.resize(label, (572,572), interpolation = cv2.INTER_AREA)
  labelcopy = label
  label2 = np.array(relabel)
#   label2 = cv2.cvtColor(lb2arr,cv2.COLOR_BGR2RGB)
#   labelcopy = cv2.cvtColor(labelcopy,cv2.COLOR_BGR2RGB)
  new_label = np.zeros((720,960,1))
  
  
  for i in range(572):
    for j in range(572):
      new_label[i+73,j+194] = label2[i,j]  
  for i in range(720):
    for j in range(194):
      new_label[i,194-j] = new_label[i,194+j]
  for i in range(720):
    for j in range(766):
      new_label[i,194-j] = new_label[i,194+j]
  for i in range(74):
    for j in range(960):
      new_label[74-i,j] = new_label[74+i,j]
  for i in range(74):
    for j in range(960):
       new_label[572+73+i,j] = new_label[572+72-i,j]
        
  
  new_label = cv2.resize(new_label, (572,572), interpolation = cv2.INTER_AREA)
  val_labels.append(new_label)
  
combined = list(zip(val_new_img,val_labels))
random.shuffle(combined)
val_new_img,val_labels = list(zip(*combined))

# ''''
# SEGMENTATION
# ''''

# SET COLORS
from matplotlib.colors import hsv_to_rgb
import random
color0 = (1, 190, 100)
color_0 = np.full((1, 1, 3), color0, dtype=np.uint8) / 255.0
color02 = (255, 190, 100)
color_02 = np.full((1, 1, 3), color02, dtype=np.uint8) / 255.0
color1 = (18, 255, 255)
color_1 = np.full((1, 1, 3), color1, dtype=np.uint8) / 255.0
color12 = (200, 200, 255)
color_12 = np.full((1, 1, 3), color12, dtype=np.uint8) / 255.0
color2 = (0 , 0 , 255)
color_2 = np.full((1, 1, 3), color2, dtype=np.uint8) / 255.0
color22 = (150, 0, 255)
color_22 = np.full((1, 1, 3), color22, dtype=np.uint8) / 255.0
color3 = (255 , 0 , 0)
color_3 = np.full((1, 1, 3), color3, dtype=np.uint8) / 255.0
color32 = (255, 80, 150)
color_32 = np.full((1, 1, 3), color32, dtype=np.uint8) / 255.0
color4 = (0 , 255, 0)
color_4 = np.full((1, 1, 3), color4, dtype=np.uint8) / 255.0
color42 = (200 , 255, 170)
color_42 = np.full((1, 1, 3), color42, dtype=np.uint8) / 255.0
color5 = (20, 130, 120)
color_5 = np.full((1, 1, 3), color5, dtype=np.uint8) / 255.0
color52 = (80, 130, 150)
color_52 = np.full((1, 1, 3), color52, dtype=np.uint8) / 255.0
color6 = (145, 60, 255)
color_6 = np.full((1, 1, 3), color6, dtype=np.uint8) / 255.0
color62 = (90 , 120 , 70)
color_62 = np.full((1, 1, 3), color62, dtype=np.uint8) / 255.0
color7 = (51 , 255 , 255)
color_7 = np.full((1, 1, 3), color7, dtype=np.uint8) / 255.0
color72 = (181 , 205 , 205)
color_72 = np.full((1, 1, 3), color72, dtype=np.uint8) / 255.0
color8 = (120 , 200 , 120)
color_8 = np.full((1, 1, 3), color8, dtype=np.uint8) / 255.0
color82 = (120 , 100 , 120)
color_82 = np.full((1, 1, 3), color82, dtype=np.uint8) / 255.0
color9 = (100 , 100 , 260)
color_9 = np.full((1, 1, 3), color9, dtype=np.uint8) / 255.0
color92 = (200 , 240 , 250)
color_92 = np.full((1, 1, 3), color92, dtype=np.uint8) / 255.0
color10 = (200 , 0 , 100)
color_10 = np.full((1, 1, 3), color10, dtype=np.uint8) / 255.0
color102 = (10 , 0 , 20)
color_102 = np.full((1, 1, 3), color102, dtype=np.uint8) / 255.0
color11 = (245, 160, 255)
color_11 = np.full((1, 1, 3), color11, dtype=np.uint8) / 255.0
color112 = (20 , 40 , 10)
color_112 = np.full((1, 1, 3), color112, dtype=np.uint8) / 255.0

# MAKING COLORFUL IMAGES 
sgmnt = []
for x in range(367):
  img = train_labels[x]
  new_img = np.zeros((572,572,3))
  for i in range(572):
    for j in range(572): 
      a=round(img[i,j],1)
      
      if (a>=0 and a<=0.5 ):
        for k in range(3):
          new_img[i,j,k]=color_0[0,0,k]
      if (a>0.5 and a<1 ):
        for k in range(3):
          new_img[i,j,k]=color_02[0,0,k]
          
      if (a>=1 and a<=1.5 ):
        for k in range(3):
          new_img[i,j,k]=color_1[0,0,k]
      if (a>1.5 and a<2 ):
        for k in range(3):
          new_img[i,j,k]=color_12[0,0,k]
          
      if (a>=2 and a<=2.5 ):
        for k in range(3):
          new_img[i,j,k]=color_2[0,0,k]
      if (a>2.5 and a<3 ):
        for k in range(3):
          new_img[i,j,k]=color_22[0,0,k]
          
      if (a>=3 and a<=3.5 ):
        for k in range(3):
          new_img[i,j,k]=color_3[0,0,k]
      if (a>3.5 and a<4 ):
        for k in range(3):
          new_img[i,j,k]=color_32[0,0,k]
          
      if (a>=4 and a<=4.5 ):
        for k in range(3):
          new_img[i,j,k]=color_4[0,0,k]
      if (a>4.5 and a<5 ):
        for k in range(3):
          new_img[i,j,k]=color_42[0,0,k]
          
      if (a>=5 and a<=5.5 ):
        for k in range(3):
          new_img[i,j,k]=color_5[0,0,k]
      if (a>5.5 and a<6 ):
        for k in range(3):
          new_img[i,j,k]=color_52[0,0,k]
          
      if (a>=6 and a<=6.5 ):
        for k in range(3):
          new_img[i,j,k]=color_6[0,0,k]
      if (a>6.5 and a<7 ):
        for k in range(3):
          new_img[i,j,k]=color_62[0,0,k]
          
      if (a>=7 and a<=7.5 ):
        for k in range(3):
          new_img[i,j,k]=color_7[0,0,k]
      if (a>7.5 and a<8 ):
        for k in range(3):
          new_img[i,j,k]=color_72[0,0,k]
          
      if (a>=8 and a<=8.5 ):
        for k in range(3):
          new_img[i,j,k]=color_8[0,0,k]
      if (a>8.5 and a<9 ):
        for k in range(3):
          new_img[i,j,k]=color_82[0,0,k]
          
      if (a>=9 and a<=9.5 ):
        for k in range(3):
          new_img[i,j,k]=color_9[0,0,k]
      if (a>9.5 and a<10 ):
        for k in range(3):
          new_img[i,j,k]=color_92[0,0,k]
          
      if (a>=10 and a<=10.5 ):
        for k in range(3):
          new_img[i,j,k]=color_10[0,0,k]
      if (a>10.5 and a<11 ):
        for k in range(3):
          new_img[i,j,k]=color_102[0,0,k]
          
      if (a>=11 and a<=11.5 ):
        for k in range(3):
          new_img[i,j,k]=color_11[0,0,k]
      if (a>11.5 and a<12 ):
        for k in range(3):
          new_img[i,j,k]=color_112[0,0,k]
          
  sgmnt.append(new_img)

from torch.utils.data import Dataset
import torch

class Caltech_Dataset(Dataset):    
    def __init__(self, images, labels):
        self.X = images
        self.Y = labels
    def __len__(self):
        return len(self.X)
    def __getitem__(self, idx):
#         import pdb;pdb.set_trace()
        image = torch.from_numpy(np.array(self.X[idx])).to(dtype=torch.float32)        
        return (image, self.Y[idx])

train_dataset=Caltech_Dataset(train_new_img,train_labels)
test_dataset=Caltech_Dataset(test_new_img,test_labels)
val_dataset=Caltech_Dataset(val_new_img,val_labels)
train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=1)
test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=1)

# Network
import torch
import torch.nn as nn
import torchvision.transforms as transforms
import torchvision.datasets as dsets
from torch.autograd import Variable

batch_size = 1
n_iters = 3000
num_epochs = n_iters / (len(train_dataset) / batch_size)
num_epochs = int(num_epochs)


class CNNModel(nn.Module):
  def __init__(self):
    super(CNNModel, self).__init__()
    
    # convolution 1
    self.cnn1 = nn.Conv2d(in_channels=1 ,out_channels=64 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu1 = nn.ReLU()
    
    # convolution 2
    self.cnn2 = nn.Conv2d(in_channels=64 ,out_channels=64 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu2 = nn.ReLU()
    
    # max pool 1 
    self.maxpool1 = nn.MaxPool2d(kernel_size=2)
    
    # convolution 3
    self.cnn3 = nn.Conv2d(in_channels=64 ,out_channels=128 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu3 = nn.ReLU()
    
    # convolution 4
    self.cnn4 = nn.Conv2d(in_channels=128 ,out_channels=128 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu4 = nn.ReLU()
    
    # max pool 2 
    self.maxpool2 = nn.MaxPool2d(kernel_size=2)
    
    # convolution 5
    self.cnn5 = nn.Conv2d(in_channels=128 ,out_channels=256 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu5 = nn.ReLU()
    
    # convolution 6
    self.cnn6 = nn.Conv2d(in_channels=256 ,out_channels=256 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu6 = nn.ReLU()
    
    # max pool 3
    self.maxpool3 = nn.MaxPool2d(kernel_size=2)
    
    # convolution 7
    self.cnn7 = nn.Conv2d(in_channels=256 ,out_channels=512 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu7 = nn.ReLU()
    
    # convolution 8
    self.cnn8 = nn.Conv2d(in_channels=512 ,out_channels=512 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu8 = nn.ReLU()
    
    # max pool 4
    self.maxpool4 = nn.MaxPool2d(kernel_size=2)
    
    # convolution 9
    self.cnn9 = nn.Conv2d(in_channels=512 ,out_channels=1024 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu9 = nn.ReLU()
    
    # convolution 10
    self.cnn10 = nn.Conv2d(in_channels=1024 ,out_channels=1024 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu10 = nn.ReLU()
    
    # up-conv 1
    self.upsample1 = nn.UpsamplingNearest2d(scale_factor=2)
    
    # convolution 11
    self.cnn11 = nn.Conv2d(in_channels=1024 ,out_channels=512 ,kernel_size=1 ,stride=1 ,padding=0)
    
    #copy & crop #
    
    # convolution 12
    self.cnn12 = nn.Conv2d(in_channels=1024 ,out_channels=512 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu12 = nn.ReLU()
    
    # convolution 13
    self.cnn13 = nn.Conv2d(in_channels=512 ,out_channels=512 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu13 = nn.ReLU()
    
    # up-conv 2
    self.upsample2 = nn.UpsamplingNearest2d(scale_factor=2)
    
    # convolution 14
    self.cnn14 = nn.Conv2d(in_channels=512 ,out_channels=256 ,kernel_size=1 ,stride=1 ,padding=0)
    
    #copy & crop #
    
    # convolution 15
    self.cnn15 = nn.Conv2d(in_channels=512 ,out_channels=256 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu15 = nn.ReLU()
    
    # convolution 16
    self.cnn16 = nn.Conv2d(in_channels=256 ,out_channels=256 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu16 = nn.ReLU()
    
    # up-conv 3
    self.upsample3 = nn.UpsamplingNearest2d(scale_factor=2)
    
    # convolution 17
    self.cnn17 = nn.Conv2d(in_channels=256 ,out_channels=128 ,kernel_size=1 ,stride=1 ,padding=0)
    
    #copy & crop #
    
    # convolution 18
    self.cnn18 = nn.Conv2d(in_channels=256 ,out_channels=128 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu18 = nn.ReLU()
    
    # convolution 19
    self.cnn19 = nn.Conv2d(in_channels=128 ,out_channels=128 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu19 = nn.ReLU()
    
    # up-conv 4
    self.upsample4 = nn.UpsamplingNearest2d(scale_factor=2)
    
    # convolution 20
    self.cnn20 = nn.Conv2d(in_channels=128 ,out_channels=64 ,kernel_size=1 ,stride=1 ,padding=0)
    
    #copy & crop #
    
    # convolution 21
    self.cnn21 = nn.Conv2d(in_channels=128 ,out_channels=64 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu21 = nn.ReLU()
    
    # convolution 22
    self.cnn22 = nn.Conv2d(in_channels=64 ,out_channels=64 ,kernel_size=3 ,stride=1 ,padding=0)
    self.relu22 = nn.ReLU()
    
    # convolution 23
    self.cnn23 = nn.Conv2d(in_channels=64 ,out_channels=32 ,kernel_size=1 ,stride=1 ,padding=0)
    
    
    
    #fully connected 1 (readout)
#     self.fc1 = nn.Linear(4608,output_dim).cuda()
    
  def forward(self, x):
        # convolution 1 
#         import pdb; pdb.set_trace()
        out = self.cnn1(x)
        out = self.relu1(out)
        # convolution 2 
        out = self.cnn2(out)
        out = self.relu2(out)
        #copy1 
        copy1 = out[:]
        # max pool 1 
        out = self.maxpool1(out)
        # convolution 3 
        out = self.cnn3(out)
        out = self.relu3(out)
        # convolution 4
        out = self.cnn4(out)
        out = self.relu4(out)
        #copy2              
        copy2 = out[:]
        # max pool 2 
        out = self.maxpool2(out)
        # convolution 5
        out = self.cnn5(out)
        out = self.relu5(out)
        # convolution 6
        out = self.cnn6(out)
        out = self.relu6(out)
        #copy3             
        copy3 = out[:]
        # max pool 3 
        out = self.maxpool3(out)
        # convolution 7 
        out = self.cnn7(out)
        out = self.relu7(out)
        # convolution 8
        out = self.cnn8(out)
        out = self.relu8(out)
        #copy4              
        copy4 = out[:]
        # max pool 4 
        out = self.maxpool4(out)
        # convolution 9
        out = self.cnn9(out)
        out = self.relu9(out)
        # convolution 10
        out = self.cnn10(out)
        out = self.relu10(out)
        # up-conv 1
        out = self.upsample1(out)
        # convolution 11 
        out = self.cnn11(out)
        # copy & crop
        out = torch.cat((out,copy4[:,:,4:60,4:60]),dim=1)
        # convolution 12 
        out = self.cnn12(out)
        out = self.relu12(out)
        # convolution 13
        out = self.cnn13(out)
        out = self.relu13(out)
        # up-conv 2
        out = self.upsample2(out)
        # convolution 14 
        out = self.cnn14(out)
        # copy & crop
        out = torch.cat((out,copy3[:,:,16:120,16:120]),dim=1)
        # convolution 15 
        out = self.cnn15(out)
        out = self.relu15(out)
        # convolution 16
        out = self.cnn16(out)
        out = self.relu16(out)
        # up-conv 3
        out = self.upsample3(out)
        # convolution 17 
        out = self.cnn17(out)
        # copy & crop
        out = torch.cat((out,copy2[:,:,40:240,40:240]),dim=1)
        # convolution 18 
        out = self.cnn18(out)
        out = self.relu18(out)
        # convolution 19
        out = self.cnn19(out)
        out = self.relu19(out)
        # up-conv 4
        out = self.upsample4(out)
        # convolution 20 
        out = self.cnn20(out)
        # copy & crop
        out = torch.cat((out,copy1[:,:,88:480,88:480]),dim=1)
        # convolution 21 
        out = self.cnn21(out)
        out = self.relu21(out)
        # convolution 22
        out = self.cnn22(out)
        out = self.relu22(out)
        # convolution 23
        out = self.cnn23(out)
        
        
#         out = out.view(out.size(0) ,-1)
        
        #linear function(readout)
#         out = self.fc1(out)
        
        return out

# INSTANTIATE MODEL CLASS
model = CNNModel()
#######################
#  USE GPU FOR MODEL  #
#######################
gpu = True
if gpu:
    model.cuda()
    
# INSTANTIATE LOSS CLASS
criterion = nn.CrossEntropyLoss()

# INSTANTIATE OPTIMIZER CLASS
learning_rate = 0.001

optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)


import matplotlib.pyplot as plt
iter =0
num_epochs = 21
for epoch in range(num_epochs):
    correct_train = 0 
    total_train = 0
    for i, (images, labels) in enumerate(train_loader):
        
        #######################
        #  USE GPU FOR MODEL  #
        #######################
        if gpu:
            images = Variable(images.view(-1,1, 572,572)).cuda()
            labels = Variable(labels).cuda()
        else:
            images = Variable(images.view(-1,1, 572,572))
            labels = Variable(labels)
        
        # Crop labels
        labels2 = labels[:,92:480,92:480]
        
        # Clear gradients w.r.t. parameters
        optimizer.zero_grad()
        
        # Forward pass to get output/logits
        outputs = model(images)
        
        # Reshape output
        # outputs2 = torch.zeros(1, 388, 388)
        # outputs2 = outputs[:,0,:,:]
        # outputs2 = outputs2.unsqueeze(0)
 
        # Calculate Loss: softmax --> cross entropy loss
        labels2=labels2.type('torch.LongTensor')
        labels2=labels2.cuda()
        # outputs2 = outputs2.cuda()
#         labels=labels.unsqueeze()
        loss = criterion(outputs, labels2)
        # Getting gradients w.r.t. parameters
        loss.backward()
        
        # Updating parameters
        optimizer.step()
        
        iter += 1
        
        if iter % 500 == 0:
            # Calculate Accuracy         
            correct = 0
            total = 0
            # Iterate through test dataset
            for images, labels in test_loader:
                #######################
                #  USE GPU FOR MODEL  #
                #######################
                if gpu:
                  images = Variable(images.view(-1,1, 572,572)).cuda()
                else:
                  images = Variable(images.view(-1,1, 572,572))
                
                 # Forward pass only to get logits/output
                outputs = model(images)
                
                # Crop labels
                labels2 = labels[:,92:480,92:480]
                labels2=labels2.type('torch.LongTensor')
                
                # Get predictions from the maximum value
                _, predicted = torch.max(outputs.data, 1)
#                 print(predicted.values)
#                 predicted = torch.max(outputs,1)
#                 predicted = predicted.item()
#                 print(type(predicted))
#                 print(predicted.shape)
                if(epoch%10==0):
                  predicted = predicted.values
                  sgmnt_img = np.zeros((388,388,3))
#                   for i in range(388):
#                     for j in range(388): 
# #                        print(predicted[i,j])
# #                        print(predicted[0,i,j])
#                       a=round(predicted,1)
      
#                       if (a>=0 and a<=0.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_0[0,0,k]
#                       if (a>0.5 and a<1 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_02[0,0,k]
            
#                       if (a>=1 and a<=1.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_1[0,0,k]
#                       if (a>1.5 and a<2 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_12[0,0,k]
          
#                       if (a>=2 and a<=2.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_2[0,0,k]
#                       if (a>2.5 and a<3 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_22[0,0,k]
          
#                       if (a>=3 and a<=3.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_3[0,0,k]
#                       if (a>3.5 and a<4 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_32[0,0,k]
            
#                       if (a>=4 and a<=4.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_4[0,0,k]
#                       if (a>4.5 and a<5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_42[0,0,k]
            
#                       if (a>=5 and a<=5.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_5[0,0,k]
#                       if (a>5.5 and a<6 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_52[0,0,k]
            
#                       if (a>=6 and a<=6.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_6[0,0,k]
#                       if (a>6.5 and a<7 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_62[0,0,k]
            
#                       if (a>=7 and a<=7.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_7[0,0,k]
#                       if (a>7.5 and a<8 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_72[0,0,k]
          
#                       if (a>=8 and a<=8.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_8[0,0,k]
#                       if (a>8.5 and a<9 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_82[0,0,k]
            
#                       if (a>=9 and a<=9.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_9[0,0,k]
#                       if (a>9.5 and a<10 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_92[0,0,k]
          
#                       if (a>=10 and a<=10.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_10[0,0,k]
#                       if (a>10.5 and a<11 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_102[0,0,k]
            
#                       if (a>=11 and a<=11.5 ):
#                         for k in range(3):
#                           sgmnt_img[i,j,k]=color_11[0,0,k]
#                       if (a>11.5 and a<12 ):
#                         for k in range(3):
                          
#                           sgmnt_img[i,j,k]=color_112[0,0,k]
                
#                   plt.imshow(sgmnt_img)
#                   plt.show()